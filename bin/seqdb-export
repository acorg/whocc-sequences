#! /usr/bin/env python3
# -*- Python -*-

"""
Exports seqdb data into fasta.
"""

import sys, os, re, functools, collections, traceback
if sys.version_info.major != 3: raise RuntimeError("Run script with python3")
sys.path[:0] = [os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0])))]
import logging; module_logger = logging.getLogger(__name__)

from whoccseq import seqdb
from whoccseq import fasta as fasta_m, open_file, utility

# ----------------------------------------------------------------------

def main(args):
    start_date = args.start_date and get_date(args.start_date)
    end_date = args.end_date and get_date(args.end_date)
    db = seqdb.SeqDB(os.path.expandvars(os.path.expanduser(args.path_to_db)))
    virus_type = db.normalize_virus_type(args.virus_type)
    name_matcher = re.compile(args.name_match, re.I) if args.name_match else None
    data = [e for e in db.iterate_sequences()
            if (not args.lab or e.lab_matches(args.lab))
            and (not virus_type or e.virus_type() == virus_type)
            and (not args.lineage or e.lineage() == args.lineage)
            and e.gene() == args.gene
            and (not args.aligned or e.shift() is not None)
            and (not start_date or (e.date() and e.date >= start_date))
            and (not end_date or (e.date() and e.date < end_date))
            and (not args.with_hi_name or e.hi_name() is not None)
            and (not name_matcher or name_matcher.search(e.name_hi()))
            ]
    module_logger.info('{} entries'.format(len(data)))
    if args.sort_by == "date":
        data.sort(key=lambda e: e.date() or "0000-00-00") # entries lacking date come first
    elif args.sort_by == "name":
        data.sort(key=lambda e: e.name_hi())
    else:
        raise ValueError("Unrecognized --sort argument")
    export(db, data, args=args)

# ----------------------------------------------------------------------

def export(db, data, args):

    def make_name_with_lab(e):
        labs = e.labs()
        if labs:
            lab = labs[0]
            lab_ids = e.lab_ids(lab)
            if lab_ids:
                lab_id = lab_ids[0]
            else:
                lab_id = ""
        else:
            lab = ""
            lab_id = ""
        return re.sub(r"\s-", "-", re.sub(r"\s+", " ", args.name_format.format(name=e.name(), hi_name=e.name_hi(), passage=e.passage(), seq_id=e.seq_id(), date=e.date() or "NO-DATE", lab_id=lab_id, lab=lab, gene=e.gene())))

    def make_name(e):
        return re.sub(r"\s-", "-", re.sub(r"\s+", " ", args.name_format.format(name=e.name(), hi_name=e.name_hi(), passage=e.passage(), seq_id=e.seq_id(), date=e.date() or "NO-DATE", gene=e.gene())))

    def make_sequence(e):
        if args.amino_acids:
            if args.aligned:
                sequence = e.aa_aligned()
            else:
                sequence = e.aa()
        else:
            if args.aligned:
                sequence = e.nuc_aligned()
            else:
                sequence = e.nuc()
        return sequence

    def truncate_extend(s, length):
        if len(s) > length:
            s = s[:length]
        elif len(s) < length:
            s = "{}{}".format(s, "-" * (length - len(s)))
        return s

    module_logger.info('Writing {}'.format(args.output))
    if "lab" in args.name_format:
        name_maker = make_name_with_lab
    else:
        name_maker = make_name
    data_to_write = [(name_maker(e), make_sequence(e)) for e in data]

    if args.most_common_length:
        len_stat = collections.Counter(len(e[1]) for e in data_to_write)
        most_common_length = len_stat.most_common(1)[0][0]
        module_logger.info('Truncating/extending sequences to the most common length: {}'.format(most_common_length))
        data_to_write = [(n, truncate_extend(s, most_common_length)) for n, s in data_to_write]

    with open_file.open_for_writing_binary(args.output) as f:
        if args.output_format == "fasta":
            export_fasta(f, data_to_write, args)
        elif args.output_format == "phylip":
            export_phylip(f, data_to_write, args)
        else:
            raise ValueError("Unsupported output format: {}".format(args.output_format))

# ----------------------------------------------------------------------

def export_fasta(f, data, args):
    for n, s in data:
        f.write(fasta_m.generate_one(name=n, sequence=s, encode=args.name_encode, split=args.sequence_wrap).encode("utf-8"))

# ----------------------------------------------------------------------

def export_phylip(f, data, args):
    if args.name_encode:
        names = [fasta_m.encode_name(n) for n, s in data]
    else:
        names = [n for n, s in data]
    max_s_len = max(len(s) for n, s in data)
    max_n_len = max(len(n) for n in names)
    f.write("{} {}\n".format(len(data), max_s_len).encode("utf-8"))
    if args.sequence_wrap:
        raise NotImplementedError("phylip with wrapping")   # http://www.molecularevolution.org/resources/fileformats/phylip_dna
    else:
        for no, (n, s) in enumerate(data):
            f.write("{:<{}s}  {}{}\n".format(names[no], max_n_len, s, "-" * (max_s_len - len(s))).encode("utf-8"))

# ----------------------------------------------------------------------

sReDate = re.compile(r"^\s*(?P<year>\d\d\d\d)[-\s]*(?P<month>\d\d)[-\s]*(?P<day>\d\d)\s*$")

def get_date(s):
    if s:
        m = sReDate.match(s)
        if not m:
            raise ValueError("Invalid date: {!r}".format(s))
        d = "-".join((m.group("year"), m.group("month"), m.group("day")))
    else:
        d = None
    return d

# ----------------------------------------------------------------------

try:
    import argparse
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('output', nargs="?", help='Fasta file to write.')
    parser.add_argument('-d', '--debug', action='store_const', dest='loglevel', const=logging.DEBUG, default=logging.INFO, help='Enable debugging output.')
    parser.add_argument('--lab', action='store', dest='lab', default=None, help='Export just for this lab.')
    parser.add_argument('--flu', action='store', dest='virus_type', default=None, help='Export just for this virus type/subtype: B, H1, H3, A(H1N1), A(H3N2).')
    parser.add_argument('--lineage', action='store', dest='lineage', default=None, help='Export just for this lineage: VICTORIA, YAMAGATA, 2009PDM.')
    parser.add_argument('--gene', action='store', dest='gene', default="HA", help='HA or NA.')
    parser.add_argument('--sort', action='store', dest='sort_by', default="date", help='Sort list before exporting by "date", "name".')
    parser.add_argument('-f', '--format', action='store', dest='output_format', default='fasta', help='Output format: fasta, phylip')
    parser.add_argument('--name-format', action='store', dest='name_format', default='{name} {passage}', help='Name format, possible fields: {name} {date} {lab_id} {passage} {lab} {gene} {seq_id}. seq_id is used for later matching with seqdb data, e.g. when phylogenetic tree is made.')
    parser.add_argument('--name-encode', action='store_true', dest='name_encode', default=False, help='Encode spaces and parentheses in names')
    parser.add_argument('--amino-acids', action='store_true', dest='amino_acids', default=False, help='Export amino-acids instead of nucleotites')
    parser.add_argument('--no-wrap', action='store_false', dest='sequence_wrap', default=True, help='Do not wrap sequence and generate long lines')
    parser.add_argument('--aligned', action='store_true', dest='aligned', default=False, help='Write aligned sequences.')
    parser.add_argument('--start-date', action='store', dest='start_date', default=None, help='Export sequences for antigens isolated on or after that date (YYYYMMDD).')
    parser.add_argument('--end-date', action='store', dest='end_date', default=None, help='Export sequences for antigens isolated before that date (YYYYMMDD).')
    parser.add_argument('--with-hi-name', action='store_true', dest='with_hi_name', default=False, help='Export sequences having hi_name only (i.e. matched with HI data).')
    parser.add_argument('--name-match', action='store', dest='name_match', default=None, help='Export sequences with names matching this regex.')
    parser.add_argument('--most-common-length', action='store_true', dest='most_common_length', default=False, help='Truncate or extend with - all sequences to make them all of the same length, most common among original sequences.')
    parser.add_argument('--db', action='store', dest='path_to_db', default='~/WHO/seqdb.json.xz', help='Path to sequence database.')
    args = parser.parse_args()
    logging.basicConfig(level=args.loglevel, format="%(levelname)s %(asctime)s: %(message)s")
    with utility.timeit(sys.argv[0]):
        exit_code = main(args)
except Exception as err:
    logging.error('{}\n{}'.format(err, traceback.format_exc()))
    exit_code = 1
exit(exit_code)

# ======================================================================
### Local Variables:
### eval: (if (fboundp 'eu-rename-buffer) (eu-rename-buffer))
### End:
